{"version":3,"file":"index.cjs","sources":["../package.json","../src/index.ts"],"sourcesContent":["{\r\n  \"name\": \"@jspsych/plugin-webgazer-validate\",\r\n  \"version\": \"2.1.0\",\r\n  \"description\": \"\",\r\n  \"type\": \"module\",\r\n  \"main\": \"dist/index.cjs\",\r\n  \"exports\": {\r\n    \"import\": \"./dist/index.js\",\r\n    \"require\": \"./dist/index.cjs\"\r\n  },\r\n  \"typings\": \"dist/index.d.ts\",\r\n  \"unpkg\": \"dist/index.browser.min.js\",\r\n  \"files\": [\r\n    \"src\",\r\n    \"dist\"\r\n  ],\r\n  \"source\": \"src/index.ts\",\r\n  \"scripts\": {\r\n    \"test\": \"jest  --passWithNoTests\",\r\n    \"test:watch\": \"npm test -- --watch\",\r\n    \"tsc\": \"tsc\",\r\n    \"build\": \"rollup --config\",\r\n    \"build:watch\": \"npm run build -- --watch\"\r\n  },\r\n  \"repository\": {\r\n    \"type\": \"git\",\r\n    \"url\": \"git+https://github.com/jspsych/jsPsych.git\",\r\n    \"directory\": \"packages/plugin-webgazer-validate\"\r\n  },\r\n  \"author\": \"Josh de Leeuw\",\r\n  \"license\": \"MIT\",\r\n  \"bugs\": {\r\n    \"url\": \"https://github.com/jspsych/jsPsych/issues\"\r\n  },\r\n  \"homepage\": \"https://www.jspsych.org/latest/plugins/webgazer-validate\",\r\n  \"peerDependencies\": {\r\n    \"jspsych\": \">=7.0.0\",\r\n    \"@jspsych/extension-webgazer\": \">=1.0.0\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@jspsych/config\": \"^3.2.0\",\r\n    \"@jspsych/extension-webgazer\": \"^1.2.0\",\r\n    \"@jspsych/test-utils\": \"^1.2.0\"\r\n  }\r\n}\r\n","import type WebGazerExtension from \"@jspsych/extension-webgazer\";\r\nimport { JsPsych, JsPsychPlugin, ParameterType, TrialType } from \"jspsych\";\r\n\r\nimport { version } from \"../package.json\";\r\n\r\nconst info = <const>{\r\n  name: \"webgazer-validate\",\r\n  version: version,\r\n  parameters: {\r\n    /** Array of points in [x,y] coordinates */\r\n    validation_points: {\r\n      type: ParameterType.INT, // TO DO: nested array, so different type?\r\n      default: [\r\n        [10, 10],\r\n        [10, 50],\r\n        [10, 90],\r\n        [50, 10],\r\n        [50, 50],\r\n        [50, 90],\r\n        [90, 10],\r\n        [90, 50],\r\n        [90, 90],\r\n      ],\r\n      array: true,\r\n    },\r\n    /**\r\n     * Are the validation_points specified as percentages of screen width and height, or the distance in pixels from the center of the screen?\r\n     * Options are 'percent' and 'center-offset-pixels'\r\n     */\r\n    validation_point_coordinates: {\r\n      type: ParameterType.SELECT,\r\n      default: \"percent\",\r\n      options: [\"percent\", \"center-offset-pixels\"],\r\n    },\r\n    /** Tolerance around validation point in pixels */\r\n    roi_radius: {\r\n      type: ParameterType.INT,\r\n      default: 200,\r\n    },\r\n    /** Whether or not to randomize the order of validation points */\r\n    randomize_validation_order: {\r\n      type: ParameterType.BOOL,\r\n      default: false,\r\n    },\r\n    /** Delay before validating after showing a point */\r\n    time_to_saccade: {\r\n      type: ParameterType.INT,\r\n      default: 1000,\r\n    },\r\n    /** Length of time to show each point */\r\n    validation_duration: {\r\n      type: ParameterType.INT,\r\n      default: 2000,\r\n    },\r\n    /** Validation point size in pixels */\r\n    point_size: {\r\n      type: ParameterType.INT,\r\n      default: 20,\r\n    },\r\n    /** If true, then validation data will be shown on the screen after validation is complete */\r\n    show_validation_data: {\r\n      type: ParameterType.BOOL,\r\n      default: false,\r\n    },\r\n  },\r\n  data: {\r\n    /** Raw gaze data for the trial. The array will contain a nested array for each validation point. Within each nested array will be a list of `{x,y,dx,dy}` values specifying the absolute x and y pixels, as well as the distance from the target for that gaze point. */\r\n    raw_gaze: {\r\n      type: ParameterType.COMPLEX,\r\n      array: true,\r\n      nested: {\r\n        x: {\r\n          type: ParameterType.INT,\r\n        },\r\n        y: {\r\n          type: ParameterType.INT,\r\n        },\r\n        dx: {\r\n          type: ParameterType.INT,\r\n        },\r\n        dy: {\r\n          type: ParameterType.INT,\r\n        },\r\n      },\r\n    },\r\n    /** The percentage of samples within the `roi_radius` for each validation point. */\r\n    percent_in_roi: {\r\n      type: ParameterType.FLOAT,\r\n      array: true,\r\n    },\r\n    /** The average `x` and `y` distance from each validation point, plus the median distance `r` of the points from this average offset. */\r\n    average_offset: {\r\n      type: ParameterType.FLOAT,\r\n      array: true,\r\n    },\r\n    /** The average number of samples per second. Calculated by finding samples per second for each point and then averaging these estimates together. */\r\n    samples_per_sec: {\r\n      type: ParameterType.FLOAT,\r\n    },\r\n    /** The list of validation points, in the order that they appeared. */\r\n    validation_points: {\r\n      type: ParameterType.INT,\r\n      array: true,\r\n    },\r\n  },\r\n  // prettier-ignore\r\n  citations: '__CITATIONS__',\r\n};\r\n\r\ntype Info = typeof info;\r\n\r\n/**\r\n * This plugin can be used to measure the accuracy and precision of gaze predictions made by the\r\n * [WebGazer extension](../extensions/webgazer.md). For a narrative description of eye tracking with jsPsych,\r\n * see the [eye tracking overview](../overview/eye-tracking.md).\r\n *\r\n * @author Josh de Leeuw\r\n * @see {@link https://www.jspsych.org/latest/plugins/webgazer-validate/ webgazer-validate plugin} and\r\n * {@link https://www.jspsych.org/latest/overview/eye-tracking/ eye-tracking overview} documentation on jspsych.org\r\n */\r\nclass WebgazerValidatePlugin implements JsPsychPlugin<Info> {\r\n  static info = info;\r\n\r\n  constructor(private jsPsych: JsPsych) {}\r\n\r\n  trial(display_element: HTMLElement, trial: TrialType<Info>) {\r\n    const extension = this.jsPsych.extensions.webgazer as WebGazerExtension;\r\n\r\n    var trial_data = <any>{};\r\n    trial_data.raw_gaze = [];\r\n    trial_data.percent_in_roi = [];\r\n    trial_data.average_offset = [];\r\n    trial_data.validation_points = null;\r\n\r\n    var html = `\r\n        <div id='webgazer-validate-container' style='position: relative; width:100vw; height:100vh; overflow: hidden;'>\r\n        </div>`;\r\n\r\n    display_element.innerHTML = html;\r\n\r\n    var wg_container = display_element.querySelector(\"#webgazer-validate-container\");\r\n\r\n    var points_completed = -1;\r\n    var val_points = null;\r\n    var start = performance.now();\r\n\r\n    // function to end trial when it is time\r\n    const end_trial = () => {\r\n      extension.stopSampleInterval();\r\n\r\n      // move on to the next trial\r\n      this.jsPsych.finishTrial(trial_data);\r\n    };\r\n\r\n    const validation_display = (pt) => {\r\n      var pt_html = drawValidationPoint(pt[0], pt[1]);\r\n      wg_container.innerHTML = pt_html;\r\n\r\n      var pt_dom = wg_container.querySelector(\".validation-point\");\r\n\r\n      var br = pt_dom.getBoundingClientRect();\r\n      var x = br.left + br.width / 2;\r\n      var y = br.top + br.height / 2;\r\n\r\n      var pt_start_val = performance.now() + trial.time_to_saccade;\r\n      var pt_finish = pt_start_val + trial.validation_duration;\r\n\r\n      var pt_data = [];\r\n\r\n      var cancelGazeUpdate = extension.onGazeUpdate((prediction) => {\r\n        if (performance.now() > pt_start_val) {\r\n          pt_data.push({\r\n            x: prediction.x,\r\n            y: prediction.y,\r\n            dx: prediction.x - x,\r\n            dy: prediction.y - y,\r\n            t: Math.round(prediction.t - start),\r\n          });\r\n        }\r\n      });\r\n\r\n      requestAnimationFrame(function watch_dot() {\r\n        if (performance.now() < pt_finish) {\r\n          requestAnimationFrame(watch_dot);\r\n        } else {\r\n          trial_data.raw_gaze.push(pt_data);\r\n          cancelGazeUpdate();\r\n\r\n          next_validation_point();\r\n        }\r\n      });\r\n    };\r\n\r\n    const next_validation_point = () => {\r\n      points_completed++;\r\n      if (points_completed == val_points.length) {\r\n        validation_done();\r\n      } else {\r\n        var pt = val_points[points_completed];\r\n        validation_display(pt);\r\n      }\r\n    };\r\n\r\n    const validate = () => {\r\n      if (trial.randomize_validation_order) {\r\n        val_points = this.jsPsych.randomization.shuffle(trial.validation_points);\r\n      } else {\r\n        val_points = trial.validation_points;\r\n      }\r\n      trial_data.validation_points = val_points;\r\n      points_completed = -1;\r\n      //extension.resume();\r\n      extension.startSampleInterval();\r\n      //extension.showPredictions();\r\n      next_validation_point();\r\n    };\r\n\r\n    const show_validation_data = () => {\r\n      var html = \"\";\r\n      for (var i = 0; i < trial.validation_points.length; i++) {\r\n        html += drawValidationPoint(trial.validation_points[i][0], trial.validation_points[i][1]);\r\n        html += drawCircle(\r\n          trial.validation_points[i][0],\r\n          trial.validation_points[i][1],\r\n          0,\r\n          0,\r\n          trial.roi_radius\r\n        );\r\n        for (var j = 0; j < trial_data.raw_gaze[i].length; j++) {\r\n          html += drawRawDataPoint(\r\n            trial.validation_points[i][0],\r\n            trial.validation_points[i][1],\r\n            trial_data.raw_gaze[i][j].dx,\r\n            trial_data.raw_gaze[i][j].dy\r\n          );\r\n        }\r\n      }\r\n\r\n      html +=\r\n        '<button id=\"cont\" style=\"position:absolute; top: 50%; left:calc(50% - 50px); width: 100px;\" class=\"jspsych-btn\">Continue</btn>';\r\n      wg_container.innerHTML = html;\r\n      wg_container.querySelector(\"#cont\").addEventListener(\"click\", () => {\r\n        extension.pause();\r\n        end_trial();\r\n      });\r\n      // turn on webgazer's loop\r\n      extension.showPredictions();\r\n      extension.stopSampleInterval();\r\n      extension.resume();\r\n    };\r\n\r\n    const validation_done = () => {\r\n      trial_data.samples_per_sec = calculateSampleRate(trial_data.raw_gaze).toFixed(2);\r\n      for (var i = 0; i < trial.validation_points.length; i++) {\r\n        trial_data.percent_in_roi[i] = calculatePercentInROI(trial_data.raw_gaze[i]);\r\n        trial_data.average_offset[i] = calculateGazeCentroid(trial_data.raw_gaze[i]);\r\n      }\r\n      if (trial.show_validation_data) {\r\n        show_validation_data();\r\n      } else {\r\n        end_trial();\r\n      }\r\n    };\r\n\r\n    validate();\r\n\r\n    // @ts-expect-error\r\n    function drawValidationPoint(x, y) {\r\n      if (trial.validation_point_coordinates == \"percent\") {\r\n        return drawValidationPoint_PercentMode(x, y);\r\n      }\r\n      if (trial.validation_point_coordinates == \"center-offset-pixels\") {\r\n        return drawValidationPoint_CenterOffsetMode(x, y);\r\n      }\r\n    }\r\n\r\n    function drawValidationPoint_PercentMode(x, y) {\r\n      return `<div class=\"validation-point\" style=\"width:${trial.point_size}px; height:${trial.point_size}px; border-radius:${trial.point_size}px; border: 1px solid #000; background-color: #333; position: absolute; left:${x}%; top:${y}%;\"></div>`;\r\n    }\r\n\r\n    function drawValidationPoint_CenterOffsetMode(x, y) {\r\n      return `<div class=\"validation-point\" style=\"width:${trial.point_size}px; height:${\r\n        trial.point_size\r\n      }px; border-radius:${\r\n        trial.point_size\r\n      }px; border: 1px solid #000; background-color: #333; position: absolute; left:calc(50% - ${\r\n        trial.point_size / 2\r\n      }px + ${x}px); top:calc(50% - ${trial.point_size / 2}px + ${y}px);\"></div>`;\r\n    }\r\n\r\n    // @ts-expect-error\r\n    function drawCircle(target_x, target_y, dx, dy, r) {\r\n      if (trial.validation_point_coordinates == \"percent\") {\r\n        return drawCircle_PercentMode(target_x, target_y, dx, dy, r);\r\n      }\r\n      if (trial.validation_point_coordinates == \"center-offset-pixels\") {\r\n        return drawCircle_CenterOffsetMode(target_x, target_y, dx, dy, r);\r\n      }\r\n    }\r\n\r\n    function drawCircle_PercentMode(target_x, target_y, dx, dy, r) {\r\n      var html = `\r\n          <div class=\"validation-centroid\" style=\"width:${r * 2}px; height:${\r\n        r * 2\r\n      }px; border: 2px dotted #ccc; border-radius: ${r}px; background-color: transparent; position: absolute; left:calc(${target_x}% + ${\r\n        dx - r\r\n      }px); top:calc(${target_y}% + ${dy - r}px);\"></div>\r\n        `;\r\n      return html;\r\n    }\r\n\r\n    function drawCircle_CenterOffsetMode(target_x, target_y, dx, dy, r) {\r\n      var html = `\r\n          <div class=\"validation-centroid\" style=\"width:${r * 2}px; height:${\r\n        r * 2\r\n      }px; border: 2px dotted #ccc; border-radius: ${r}px; background-color: transparent; position: absolute; left:calc(50% + ${target_x}px + ${\r\n        dx - r\r\n      }px); top:calc(50% + ${target_y}px + ${dy - r}px);\"></div>\r\n        `;\r\n      return html;\r\n    }\r\n\r\n    // @ts-expect-error\r\n    function drawRawDataPoint(target_x, target_y, dx, dy) {\r\n      if (trial.validation_point_coordinates == \"percent\") {\r\n        return drawRawDataPoint_PercentMode(target_x, target_y, dx, dy);\r\n      }\r\n      if (trial.validation_point_coordinates == \"center-offset-pixels\") {\r\n        return drawRawDataPoint_CenterOffsetMode(target_x, target_y, dx, dy);\r\n      }\r\n    }\r\n\r\n    function drawRawDataPoint_PercentMode(target_x, target_y, dx, dy) {\r\n      var color = Math.sqrt(dx * dx + dy * dy) <= trial.roi_radius ? \"#afa\" : \"#faa\";\r\n      return `<div class=\"raw-data-point\" style=\"width:5px; height:5px; border-radius:5px; background-color: ${color}; opacity:0.8; position: absolute; left:calc(${target_x}% + ${\r\n        dx - 2\r\n      }px); top:calc(${target_y}% + ${dy - 2}px);\"></div>`;\r\n    }\r\n\r\n    function drawRawDataPoint_CenterOffsetMode(target_x, target_y, dx, dy) {\r\n      var color = Math.sqrt(dx * dx + dy * dy) <= trial.roi_radius ? \"#afa\" : \"#faa\";\r\n      return `<div class=\"raw-data-point\" style=\"width:5px; height:5px; border-radius:5px; background-color: ${color}; opacity:0.8; position: absolute; left:calc(50% + ${target_x}px + ${\r\n        dx - 2\r\n      }px); top:calc(50% + ${target_y}px + ${dy - 2}px);\"></div>`;\r\n    }\r\n\r\n    function median(arr) {\r\n      var mid = Math.floor(arr.length / 2);\r\n      var sorted_arr = arr.sort((a, b) => a - b);\r\n      if (arr.length % 2 == 0) {\r\n        return sorted_arr[mid - 1] + sorted_arr[mid] / 2;\r\n      } else {\r\n        return sorted_arr[mid];\r\n      }\r\n    }\r\n\r\n    function calculateGazeCentroid(gazeData) {\r\n      var x_diff_m = gazeData.reduce((accumulator, currentValue, index) => {\r\n        accumulator += currentValue.dx;\r\n        if (index == gazeData.length - 1) {\r\n          return accumulator / gazeData.length;\r\n        } else {\r\n          return accumulator;\r\n        }\r\n      }, 0);\r\n\r\n      var y_diff_m = gazeData.reduce((accumulator, currentValue, index) => {\r\n        accumulator += currentValue.dy;\r\n        if (index == gazeData.length - 1) {\r\n          return accumulator / gazeData.length;\r\n        } else {\r\n          return accumulator;\r\n        }\r\n      }, 0);\r\n\r\n      var median_distance = median(\r\n        gazeData.map((x) => Math.sqrt(Math.pow(x.dx - x_diff_m, 2) + Math.pow(x.dy - y_diff_m, 2)))\r\n      );\r\n\r\n      return {\r\n        x: x_diff_m,\r\n        y: y_diff_m,\r\n        r: median_distance,\r\n      };\r\n    }\r\n\r\n    function calculatePercentInROI(gazeData) {\r\n      var distances = gazeData.map((p) => Math.sqrt(Math.pow(p.dx, 2) + Math.pow(p.dy, 2)));\r\n      var sum_in_roi = distances.reduce((accumulator, currentValue) => {\r\n        if (currentValue <= trial.roi_radius) {\r\n          accumulator++;\r\n        }\r\n        return accumulator;\r\n      }, 0);\r\n      var percent = (sum_in_roi / gazeData.length) * 100;\r\n      return percent;\r\n    }\r\n\r\n    function calculateSampleRate(gazeData) {\r\n      var mean_diff = [];\r\n      if (gazeData.length == 0) {\r\n        return 0;\r\n      }\r\n      for (var i = 0; i < gazeData.length; i++) {\r\n        if (gazeData[i].length > 1) {\r\n          var t_diff = [];\r\n          for (var j = 1; j < gazeData[i].length; j++) {\r\n            t_diff.push(gazeData[i][j].t - gazeData[i][j - 1].t);\r\n          }\r\n          mean_diff.push(t_diff.reduce((a, b) => a + b, 0) / t_diff.length);\r\n        }\r\n      }\r\n      if (mean_diff.length > 0) {\r\n        return 1000 / (mean_diff.reduce((a, b) => a + b, 0) / mean_diff.length);\r\n      } else {\r\n        return null;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default WebgazerValidatePlugin;\r\n"],"names":[],"mappings":";;;;AAEE,IAAW,OAAA,GAAA,OAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECwGA,SAAA,EAAA;AAAA;;GAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}