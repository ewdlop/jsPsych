{"version":3,"file":"index.browser.js","sources":["../package.json","../src/index.ts"],"sourcesContent":["{\r\n  \"name\": \"@jspsych/plugin-webgazer-calibrate\",\r\n  \"version\": \"2.1.0\",\r\n  \"description\": \"\",\r\n  \"type\": \"module\",\r\n  \"main\": \"dist/index.cjs\",\r\n  \"exports\": {\r\n    \"import\": \"./dist/index.js\",\r\n    \"require\": \"./dist/index.cjs\"\r\n  },\r\n  \"typings\": \"dist/index.d.ts\",\r\n  \"unpkg\": \"dist/index.browser.min.js\",\r\n  \"files\": [\r\n    \"src\",\r\n    \"dist\"\r\n  ],\r\n  \"source\": \"src/index.ts\",\r\n  \"scripts\": {\r\n    \"test\": \"jest  --passWithNoTests\",\r\n    \"test:watch\": \"npm test -- --watch\",\r\n    \"tsc\": \"tsc\",\r\n    \"build\": \"rollup --config\",\r\n    \"build:watch\": \"npm run build -- --watch\"\r\n  },\r\n  \"repository\": {\r\n    \"type\": \"git\",\r\n    \"url\": \"git+https://github.com/jspsych/jsPsych.git\",\r\n    \"directory\": \"packages/plugin-webgazer-calibrate\"\r\n  },\r\n  \"author\": \"Josh de Leeuw\",\r\n  \"license\": \"MIT\",\r\n  \"bugs\": {\r\n    \"url\": \"https://github.com/jspsych/jsPsych/issues\"\r\n  },\r\n  \"homepage\": \"https://www.jspsych.org/latest/plugins/webgazer-calibrate\",\r\n  \"peerDependencies\": {\r\n    \"jspsych\": \">=7.0.0\",\r\n    \"@jspsych/extension-webgazer\": \">=1.0.0\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@jspsych/config\": \"^3.2.0\",\r\n    \"@jspsych/extension-webgazer\": \"^1.2.0\",\r\n    \"@jspsych/test-utils\": \"^1.2.0\"\r\n  }\r\n}\r\n","import type WebGazerExtension from \"@jspsych/extension-webgazer\";\r\nimport { JsPsych, JsPsychPlugin, ParameterType, TrialType } from \"jspsych\";\r\n\r\nimport { version } from \"../package.json\";\r\n\r\nconst info = <const>{\r\n  name: \"webgazer-calibrate\",\r\n  version: version,\r\n  parameters: {\r\n    /** Array of points in `[x,y]` coordinates. Specified as a percentage of the screen width and height, from the left and top edge. The default grid is 9 points. */\r\n    calibration_points: {\r\n      type: ParameterType.INT, // TO DO: nested array, so different type?\r\n      default: [\r\n        [10, 10],\r\n        [10, 50],\r\n        [10, 90],\r\n        [50, 10],\r\n        [50, 50],\r\n        [50, 90],\r\n        [90, 10],\r\n        [90, 50],\r\n        [90, 90],\r\n      ],\r\n      array: true,\r\n    },\r\n    /** Can specify `click` to have participants click on calibration points or `view` to have participants passively watch calibration points.  */\r\n    calibration_mode: {\r\n      type: ParameterType.SELECT,\r\n      options: [\"click\", \"view\"],\r\n      default: \"click\",\r\n    },\r\n    /** Diameter of the calibration points in pixels. */\r\n    point_size: {\r\n      type: ParameterType.INT,\r\n      default: 20,\r\n    },\r\n    /** The number of times to repeat the sequence of calibration points. */\r\n    repetitions_per_point: {\r\n      type: ParameterType.INT,\r\n      default: 1,\r\n    },\r\n    /** Whether to randomize the order of the calibration points. */\r\n    randomize_calibration_order: {\r\n      type: ParameterType.BOOL,\r\n      default: false,\r\n    },\r\n    /** If `calibration_mode` is set to `view`, then this is the delay before calibrating after showing a point.\r\n     * Gives the participant time to fixate on the new target before assuming that the participant is looking at the target. */\r\n    time_to_saccade: {\r\n      type: ParameterType.INT,\r\n      default: 1000,\r\n    },\r\n    /**\r\n     * If `calibration_mode` is set to `view`, then this is the length of time to show a point while calibrating. Note\r\n     * that if `click` calibration is used then the point will remain on the screen until clicked.\r\n     */\r\n    time_per_point: {\r\n      type: ParameterType.INT,\r\n      default: 1000,\r\n    },\r\n  },\r\n  data: {\r\n    // no data collected\r\n  },\r\n  // prettier-ignore\r\n  citations: '__CITATIONS__',\r\n};\r\n\r\ntype Info = typeof info;\r\n\r\n/**\r\n *\r\n * This plugin can be used to calibrate the [WebGazer extension](../extensions/webgazer.md). For a narrative\r\n * description of eye tracking with jsPsych, see the [eye tracking overview](../overview/eye-tracking.md).\r\n *\r\n * @author Josh de Leeuw\r\n * @see {@link https://www.jspsych.org/latest/plugins/webgazer-calibrate/ webgazer-calibrate plugin} and\r\n * {@link https://www.jspsych.org/latest/overview/eye-tracking/ eye-tracking overview} documentation on jspsych.org\r\n */\r\nclass WebgazerCalibratePlugin implements JsPsychPlugin<Info> {\r\n  static info = info;\r\n\r\n  constructor(private jsPsych: JsPsych) {}\r\n\r\n  trial(display_element: HTMLElement, trial: TrialType<Info>) {\r\n    const extension = this.jsPsych.extensions.webgazer as WebGazerExtension;\r\n\r\n    var html = `\r\n          <div id='webgazer-calibrate-container' style='position: relative; width:100vw; height:100vh'>\r\n          </div>`;\r\n\r\n    display_element.innerHTML = html;\r\n\r\n    var wg_container = display_element.querySelector(\"#webgazer-calibrate-container\");\r\n\r\n    var reps_completed = 0;\r\n    var points_completed = -1;\r\n    var cal_points = null;\r\n\r\n    const next_calibration_round = () => {\r\n      if (trial.randomize_calibration_order) {\r\n        cal_points = this.jsPsych.randomization.shuffle(trial.calibration_points);\r\n      } else {\r\n        cal_points = trial.calibration_points;\r\n      }\r\n      points_completed = -1;\r\n      next_calibration_point();\r\n    };\r\n\r\n    const calibrate = () => {\r\n      extension.resume();\r\n      if (trial.calibration_mode == \"click\") {\r\n        extension.startMouseCalibration();\r\n      }\r\n      next_calibration_round();\r\n    };\r\n\r\n    const next_calibration_point = () => {\r\n      points_completed++;\r\n      if (points_completed == cal_points.length) {\r\n        reps_completed++;\r\n        if (reps_completed == trial.repetitions_per_point) {\r\n          calibration_done();\r\n        } else {\r\n          next_calibration_round();\r\n        }\r\n      } else {\r\n        var pt = cal_points[points_completed];\r\n        calibration_display_gaze_only(pt);\r\n      }\r\n    };\r\n\r\n    const calibration_display_gaze_only = (pt) => {\r\n      var pt_html = `<div id=\"calibration-point\" style=\"width:${trial.point_size}px; height:${trial.point_size}px; border-radius:${trial.point_size}px; border: 1px solid #000; background-color: #333; position: absolute; left:${pt[0]}%; top:${pt[1]}%;\"></div>`;\r\n      wg_container.innerHTML = pt_html;\r\n\r\n      var pt_dom = wg_container.querySelector<HTMLElement>(\"#calibration-point\");\r\n\r\n      if (trial.calibration_mode == \"click\") {\r\n        pt_dom.style.cursor = \"pointer\";\r\n        pt_dom.addEventListener(\"click\", () => {\r\n          next_calibration_point();\r\n        });\r\n      }\r\n\r\n      if (trial.calibration_mode == \"view\") {\r\n        var br = pt_dom.getBoundingClientRect();\r\n        var x = br.left + br.width / 2;\r\n        var y = br.top + br.height / 2;\r\n\r\n        var pt_start_cal: number = performance.now() + trial.time_to_saccade;\r\n        var pt_finish: number = performance.now() + trial.time_to_saccade + trial.time_per_point;\r\n\r\n        const watch_dot = () => {\r\n          if (performance.now() > pt_start_cal) {\r\n            extension.calibratePoint(x, y);\r\n          }\r\n          if (performance.now() < pt_finish) {\r\n            requestAnimationFrame(watch_dot);\r\n          } else {\r\n            next_calibration_point();\r\n          }\r\n        };\r\n\r\n        requestAnimationFrame(watch_dot);\r\n      }\r\n    };\r\n\r\n    const calibration_done = () => {\r\n      if (trial.calibration_mode == \"click\") {\r\n        extension.stopMouseCalibration();\r\n      }\r\n      wg_container.innerHTML = \"\";\r\n      end_trial();\r\n    };\r\n\r\n    // function to end trial when it is time\r\n    const end_trial = () => {\r\n      extension.pause();\r\n      extension.hidePredictions();\r\n      extension.hideVideo();\r\n\r\n      // gather the data to store for the trial\r\n      var trial_data = {};\r\n\r\n      // move on to the next trial\r\n      this.jsPsych.finishTrial(trial_data);\r\n    };\r\n\r\n    calibrate();\r\n  }\r\n}\r\n\r\nexport default WebgazerCalibratePlugin;\r\n"],"names":[],"mappings":";;;EAEE,IAAW,OAAA,GAAA,OAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IC+DA,SAAA,EAAA;EAAA;;KAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}