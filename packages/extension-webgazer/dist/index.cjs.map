{"version":3,"file":"index.cjs","sources":["../package.json","../src/index.ts"],"sourcesContent":["{\r\n  \"name\": \"@jspsych/extension-webgazer\",\r\n  \"version\": \"1.2.0\",\r\n  \"description\": \"jsPsych extension for eye tracking using WebGazer.js\",\r\n  \"type\": \"module\",\r\n  \"main\": \"dist/index.cjs\",\r\n  \"exports\": {\r\n    \"import\": \"./dist/index.js\",\r\n    \"require\": \"./dist/index.cjs\"\r\n  },\r\n  \"typings\": \"dist/index.d.ts\",\r\n  \"unpkg\": \"dist/index.browser.min.js\",\r\n  \"files\": [\r\n    \"src\",\r\n    \"dist\"\r\n  ],\r\n  \"source\": \"src/index.ts\",\r\n  \"scripts\": {\r\n    \"test\": \"jest --passWithNoTests\",\r\n    \"test:watch\": \"npm test -- --watch\",\r\n    \"tsc\": \"tsc\",\r\n    \"build\": \"rollup --config\",\r\n    \"build:watch\": \"npm run build -- --watch\"\r\n  },\r\n  \"repository\": {\r\n    \"type\": \"git\",\r\n    \"url\": \"git+https://github.com/jspsych/jsPsych.git\",\r\n    \"directory\": \"packages/extension-webgazer\"\r\n  },\r\n  \"author\": \"Josh de Leeuw\",\r\n  \"license\": \"MIT\",\r\n  \"bugs\": {\r\n    \"url\": \"https://github.com/jspsych/jsPsych/issues\"\r\n  },\r\n  \"homepage\": \"https://www.jspsych.org/latest/extensions/webgazer\",\r\n  \"peerDependencies\": {\r\n    \"jspsych\": \">=7.0.0\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@jspsych/config\": \"^3.2.0\",\r\n    \"@jspsych/test-utils\": \"^1.2.0\"\r\n  }\r\n}\r\n","import { JsPsych, JsPsychExtension, JsPsychExtensionInfo, ParameterType } from \"jspsych\";\r\n\r\nimport { version } from \"../package.json\";\r\n\r\n// we have to add webgazer to the global window object because webgazer attaches itself to\r\n// the window when it loads\r\ndeclare global {\r\n  interface Window {\r\n    webgazer: any;\r\n  }\r\n}\r\n\r\ninterface InitializeParameters {\r\n  /**\r\n   * Whether to round WebGazer's predicted x, y coordinates to the nearest integer. Recommended\r\n   * to leave this as `true` because it saves significant space in the data object and the\r\n   * predictions aren't precise to the level of partial pixels.\r\n   * @default true\r\n   */\r\n  round_predictions: boolean;\r\n  /**\r\n   * Whether to initialize WebGazer automatically when the plugin loads. Leave this as `false`\r\n   * if you plan to initialize WebGazer later in the experiment using a plugin.\r\n   * @default false\r\n   */\r\n  auto_initialize: boolean;\r\n  /**\r\n   * The number of milliseconds between each sample. Note that this is only a request, and the\r\n   * actual interval will vary depending on processing time.\r\n   * @default 34\r\n   */\r\n  sampling_interval: number;\r\n  /**\r\n   * An instance of WebGazer. If left undefined then the global window.webgazer object will be used\r\n   * if it exists.\r\n   */\r\n  webgazer: any;\r\n}\r\n\r\ninterface OnStartParameters {\r\n  targets: Array<string>;\r\n}\r\n\r\n/**\r\n * https://www.jspsych.org/latest/extensions/webgazer/\r\n */\r\nclass WebGazerExtension implements JsPsychExtension {\r\n  static info: JsPsychExtensionInfo = {\r\n    name: \"webgazer\",\r\n    version: version,\r\n    data: {\r\n      /** An array of objects containing gaze data for the trial. Each object has an `x`, a `y`, and a `t` property. The `x` and\r\n       * `y` properties specify the gaze location in pixels and `t` specifies the time in milliseconds since the start of the trial.\r\n       */\r\n      webgazer_data: {\r\n        type: ParameterType.INT,\r\n        array: true,\r\n      },\r\n      /** An object contain the pixel coordinates of elements on the screen specified by the `.targets` parameter. Each key in this\r\n       * object will be a `selector` property, containing the CSS selector string used to find the element. The object corresponding\r\n       * to each key will contain `x` and `y` properties specifying the top-left corner of the object, `width` and `height` values,\r\n       * plus `top`, `bottom`, `left`, and `right` parameters which specify the [bounding rectangle](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect) of the element.\r\n       */\r\n      webgazer_targets: {\r\n        type: ParameterType.COMPLEX,\r\n        nested: {\r\n          x: {\r\n            type: ParameterType.INT,\r\n          },\r\n          y: {\r\n            type: ParameterType.INT,\r\n          },\r\n          width: {\r\n            type: ParameterType.INT,\r\n          },\r\n          height: {\r\n            type: ParameterType.INT,\r\n          },\r\n          top: {\r\n            type: ParameterType.INT,\r\n          },\r\n          bottom: {\r\n            type: ParameterType.INT,\r\n          },\r\n          left: {\r\n            type: ParameterType.INT,\r\n          },\r\n          right: {\r\n            type: ParameterType.INT,\r\n          },\r\n        },\r\n      },\r\n    },\r\n    // prettier-ignore\r\n    citations: '__CITATIONS__',\r\n  };\r\n\r\n  constructor(private jsPsych: JsPsych) {}\r\n\r\n  // private state for the extension\r\n  // extension authors can define public functions to interact\r\n  // with the state. recommend not exposing state directly\r\n  // so that state manipulations are checked.\r\n  private currentTrialData = [];\r\n  private currentTrialTargets = {};\r\n  private currentTrialSelectors: Array<string>;\r\n  private domObserver: MutationObserver;\r\n  private webgazer;\r\n  private initialized = false;\r\n  private currentTrialStart: number;\r\n  private activeTrial = false;\r\n  private sampling_interval: number;\r\n  private round_predictions: boolean;\r\n  private gazeInterval: ReturnType<typeof setInterval>;\r\n  private gazeUpdateCallbacks: Array<any>;\r\n  private currentGaze: Object;\r\n\r\n  initialize = ({\r\n    round_predictions = true,\r\n    auto_initialize = false,\r\n    sampling_interval = 34,\r\n    webgazer,\r\n  }: InitializeParameters): Promise<void> => {\r\n    // set initial state of the extension\r\n    this.round_predictions = round_predictions;\r\n    this.sampling_interval = sampling_interval;\r\n    this.gazeUpdateCallbacks = [];\r\n    this.domObserver = new MutationObserver(this.mutationObserverCallback);\r\n\r\n    return new Promise((resolve, reject) => {\r\n      if (typeof webgazer === \"undefined\") {\r\n        if (window.webgazer) {\r\n          this.webgazer = window.webgazer;\r\n        } else {\r\n          reject(\r\n            new Error(\r\n              \"Webgazer extension failed to initialize. webgazer.js not loaded. Load webgazer.js before calling initJsPsych()\"\r\n            )\r\n          );\r\n        }\r\n      } else {\r\n        this.webgazer = webgazer;\r\n      }\r\n\r\n      // sets up event handler for webgazer data\r\n      // this.webgazer.setGazeListener(this.handleGazeDataUpdate);\r\n\r\n      // default to threadedRidge regression\r\n      // NEVER MIND... kalman filter is too useful.\r\n      //state.webgazer.workerScriptURL = 'js/webgazer/ridgeWorker.mjs';\r\n      //state.webgazer.setRegression('threadedRidge');\r\n      //state.webgazer.applyKalmanFilter(false); // kalman filter doesn't seem to work yet with threadedridge.\r\n\r\n      // hide video by default\r\n      this.hideVideo();\r\n\r\n      // hide predictions by default\r\n      this.hidePredictions();\r\n\r\n      if (auto_initialize) {\r\n        // starts webgazer, and once it initializes we stop mouseCalibration and\r\n        // pause webgazer data.\r\n        this.webgazer\r\n          .begin()\r\n          .then(() => {\r\n            this.initialized = true;\r\n            this.stopMouseCalibration();\r\n            this.pause();\r\n            resolve();\r\n          })\r\n          .catch((error) => {\r\n            console.error(error);\r\n            reject(error);\r\n          });\r\n      } else {\r\n        resolve();\r\n      }\r\n    });\r\n  };\r\n\r\n  on_start = (params: OnStartParameters): void => {\r\n    this.currentTrialData = [];\r\n    this.currentTrialTargets = {};\r\n    this.currentTrialSelectors = params.targets;\r\n\r\n    this.domObserver.observe(this.jsPsych.getDisplayElement(), { childList: true });\r\n  };\r\n\r\n  on_load = () => {\r\n    // set current trial start time\r\n    this.currentTrialStart = performance.now();\r\n\r\n    // resume data collection\r\n    // state.webgazer.resume();\r\n\r\n    this.startSampleInterval();\r\n\r\n    // set internal flag\r\n    this.activeTrial = true;\r\n  };\r\n\r\n  on_finish = () => {\r\n    // pause the eye tracker\r\n    this.stopSampleInterval();\r\n\r\n    // stop watching the DOM\r\n    this.domObserver.disconnect();\r\n\r\n    // state.webgazer.pause();\r\n\r\n    // set internal flag\r\n    this.activeTrial = false;\r\n\r\n    // send back the gazeData\r\n    return {\r\n      webgazer_data: this.currentTrialData,\r\n      webgazer_targets: this.currentTrialTargets,\r\n    };\r\n  };\r\n\r\n  start = () => {\r\n    return new Promise<void>((resolve, reject) => {\r\n      if (typeof this.webgazer == \"undefined\") {\r\n        const error =\r\n          \"Failed to start webgazer. Things to check: Is webgazer.js loaded? Is the webgazer extension included in initJsPsych?\";\r\n        console.error(error);\r\n        reject(error);\r\n      }\r\n      this.webgazer\r\n        .begin()\r\n        .then(() => {\r\n          this.initialized = true;\r\n          this.stopMouseCalibration();\r\n          this.pause();\r\n          resolve();\r\n        })\r\n        .catch((error) => {\r\n          console.error(error);\r\n          reject(error);\r\n        });\r\n    });\r\n  };\r\n\r\n  startSampleInterval = (interval: number = this.sampling_interval) => {\r\n    this.gazeInterval = setInterval(() => {\r\n      this.webgazer.getCurrentPrediction().then(this.handleGazeDataUpdate);\r\n    }, interval);\r\n    // repeat the call here so that we get one immediate execution. above will not\r\n    // start until state.sampling_interval is reached the first time.\r\n    this.webgazer.getCurrentPrediction().then(this.handleGazeDataUpdate);\r\n  };\r\n\r\n  stopSampleInterval = () => {\r\n    clearInterval(this.gazeInterval);\r\n  };\r\n\r\n  isInitialized = () => {\r\n    return this.initialized;\r\n  };\r\n\r\n  faceDetected = () => {\r\n    return this.webgazer.getTracker().predictionReady;\r\n  };\r\n\r\n  showPredictions = () => {\r\n    this.webgazer.showPredictionPoints(true);\r\n  };\r\n\r\n  hidePredictions = () => {\r\n    this.webgazer.showPredictionPoints(false);\r\n  };\r\n\r\n  showVideo = () => {\r\n    this.webgazer.showVideo(true);\r\n    this.webgazer.showFaceOverlay(true);\r\n    this.webgazer.showFaceFeedbackBox(true);\r\n  };\r\n\r\n  hideVideo = () => {\r\n    this.webgazer.showVideo(false);\r\n    this.webgazer.showFaceOverlay(false);\r\n    this.webgazer.showFaceFeedbackBox(false);\r\n  };\r\n\r\n  resume = () => {\r\n    this.webgazer.resume();\r\n  };\r\n\r\n  pause = () => {\r\n    this.webgazer.pause();\r\n    // sometimes gaze dot will show and freeze after pause?\r\n    if (document.querySelector(\"#webgazerGazeDot\")) {\r\n      document.querySelector<HTMLElement>(\"#webgazerGazeDot\").style.display = \"none\";\r\n    }\r\n  };\r\n\r\n  resetCalibration = () => {\r\n    this.webgazer.clearData();\r\n  };\r\n\r\n  stopMouseCalibration = () => {\r\n    this.webgazer.removeMouseEventListeners();\r\n  };\r\n\r\n  startMouseCalibration = () => {\r\n    this.webgazer.addMouseEventListeners();\r\n  };\r\n\r\n  calibratePoint = (x: number, y: number) => {\r\n    this.webgazer.recordScreenPosition(x, y, \"click\");\r\n  };\r\n\r\n  setRegressionType = (regression_type) => {\r\n    var valid_regression_models = [\"ridge\", \"weightedRidge\", \"threadedRidge\"];\r\n    if (valid_regression_models.includes(regression_type)) {\r\n      this.webgazer.setRegression(regression_type);\r\n    } else {\r\n      console.warn(\r\n        \"Invalid regression_type parameter for webgazer.setRegressionType. Valid options are ridge, weightedRidge, and threadedRidge.\"\r\n      );\r\n    }\r\n  };\r\n\r\n  getCurrentPrediction = () => {\r\n    return this.webgazer.getCurrentPrediction();\r\n  };\r\n\r\n  onGazeUpdate = (callback) => {\r\n    this.gazeUpdateCallbacks.push(callback);\r\n    return () => {\r\n      this.gazeUpdateCallbacks = this.gazeUpdateCallbacks.filter((item) => {\r\n        return item !== callback;\r\n      });\r\n    };\r\n  };\r\n\r\n  private handleGazeDataUpdate = (gazeData, elapsedTime) => {\r\n    if (gazeData !== null) {\r\n      var d = {\r\n        x: this.round_predictions ? Math.round(gazeData.x) : gazeData.x,\r\n        y: this.round_predictions ? Math.round(gazeData.y) : gazeData.y,\r\n        t: gazeData.t,\r\n      };\r\n      if (this.activeTrial) {\r\n        //console.log(`handleUpdate: t = ${Math.round(gazeData.t)}, now = ${Math.round(performance.now())}`);\r\n        d.t = Math.round(gazeData.t - this.currentTrialStart);\r\n        this.currentTrialData.push(d); // add data to current trial's data\r\n      }\r\n      this.currentGaze = d;\r\n      for (var i = 0; i < this.gazeUpdateCallbacks.length; i++) {\r\n        this.gazeUpdateCallbacks[i](d);\r\n      }\r\n    } else {\r\n      this.currentGaze = null;\r\n    }\r\n  };\r\n\r\n  private mutationObserverCallback = (mutationsList, observer) => {\r\n    for (const selector of this.currentTrialSelectors) {\r\n      if (!this.currentTrialTargets[selector]) {\r\n        if (this.jsPsych.getDisplayElement().querySelector(selector)) {\r\n          var coords = this.jsPsych\r\n            .getDisplayElement()\r\n            .querySelector(selector)\r\n            .getBoundingClientRect();\r\n          this.currentTrialTargets[selector] = coords;\r\n        }\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\nexport default WebGazerExtension;\r\n"],"names":[],"mappings":";;;;AAEE,IAAW,OAAA,GAAA,OAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MC4FE,SAAA,EAAA;AAAA;;OAAe;AAAA;;;;;;"}